= Bare metal Java
:idprefix:
:stem: asciimath
:backend: html
:source-highlighter: highlightjs
:highlightjs-style: github
:revealjs_history: true
:revealjs_theme: night
:revealjs_controls: false
:revealjs_width: 1920
:revealjs_height: 1080
:imagesdir: images
:customcss: css/custom.css
:icons: font
:title-slide-background-image: pexels-pixabay-327049.jpg

== about me

Jarek Pałka (@j_palka)

Neo4j (a graph database) performance engineer/team lead

over 20 years with JVM ( and people) +
speaker, coder, architect

founder of SegFault conference +
godfather of Programistyczna Grupa Rozwoju

== DISCLAIMER

this presentation may contain strong language, +
my own opinions, references
to sex, drugs, religion, alcohol and politics

if this does make you feel offended +
that's good it means you have something you care about in your life

== the raise and fall on managed runtime

yet another taxonomy of programming languages

* compiled (C/C++)
* compiled with managed runtime (Go, Pony)
* interpreted with managed runtime (LISP,Smalltalk,Java,C#,JavaScript,Erlang,Python, PHP, Perl) (aka virtual machines)

=== managed runtime

all the hard things

* memory management (garbage collectors)
* threads management
* code management (runtime linking)
* calling native code (because we are interpreted)
* (operating system abstraction)*

=== why?

to give up control for safety

=== !

* memory safety
* operation safety
* execution safety

=== !

when you give up control, +
you loose a lot of opportunities to optimize your code +
(notice I didn't say you loose performance)

== Java as a system's language?

stupid idea!
(especially when management of resources is critical)

=== !

Apache Kafka +
Neo4j +
Elastic +
Hazelcast +
Cassandra +
Apache BigData Ecosystem

=== are these people stupid or?

crazy?

=== !

no

safety is more important than speed

you don't want your databases to randomly crash

=== but all we need is

need for speed :)

=== sun.misc.Unsafe

internal API abused beyond creators imagination

* memory allocation
* object layout
* low level concurrency controls
* serialization

=== welcome, bare metal Java

* foreign memory
* foreign linker
* vectorization
* frozen arrays, i całą seria optymalizacji, która za tym idzie
* primitive objects (i projekt Valhalla)
* low-level concurrency controls

== malloc baby

=== DirectByteBuffer

freeing unused memory (famous Cleaner)
inefficient under pressure

=== Unsafe.allocateMemory

breaks memory safety guarantees, not official API,

=== JNI

=== it takes three

* first proposed by JEP 370 and targeted to Java 14
* and later re-incubated by JEP 383 which was targeted to Java 15
* third proposal https://openjdk.java.net/jeps/393[JEP 393] released with Java 16

=== goals

[quote,,JEP 393]
Generality: A single API should be able to operate on various kinds of foreign memory (e.g., native memory,     persistent memory, managed heap memory, etc.).

=== goals

[quote,,JEP 393]
Safety: It should not be possible for the API to undermine the safety of the JVM, regardless of the kind of memory being operated upon.

=== goals

[quote,,JEP 393]
Control: Clients should have options as to how memory segments are to be deallocated: either explicitly (via a method call) or implicitly (when the segment is no longer in use).

=== goals

[quote,,JEP 393]
Usability: For programs that need to access foreign memory, the API should be a compelling alternative to legacy Java APIs such as sun.misc.Unsafe.

=== concepts

* MemorySegment
* MemoryAddress
* MemoryLayout

=== MemorySegment

models a contiguous memory region with given spatial and temporal bounds,
any access outside spatial or temporal bounds will end upt with exception

[code,java]
----
try(var memorySegment = MemorySegment.allocateNative(1024)){
}
----

=== !

[code,java]
----
var memorySegment = MemorySegment.allocateNative(1024))
// lots of code
memorySegment.close(); // hi, manuall memory management
----

=== !

[code,java]
----
var memorySegment = MemorySegment.allocateNative(1024));
var cleaner = Cleaner.create(); //uses PhantomReferences and ReferenceQueue
memorySegment.registerCleaner(cleaner);
----

=== !

memory segment can be:

* on-heap
* off-heap
* memory mapped file
* NVRAM (https://openjdk.java.net/jeps/352[JEP 352: Non-Volatile Mapped Byte Buffers])

=== thread confinement

by default, memory segments are confined to thread it created,
any access from other threads is forbidden,

you can change ownership of segment or make it shareable

[code,java]
----
try(var memorySegment = MemorySegment.allocateNative(1024)){
    var newOwnerMemorySegment = memorySegment.handoff(otherThread);
    // from now on, access to memorySegment is forbiden
    var sharedMemorySegment = newOwnerMemorySegment.share();
    // now you can share segment between threads,
    //they still point to same memory address
}
----

=== native scope

[code,java]
----
try(var memorySegment = MemorySegment.allocateNative(1024)){
}
----

=== dereferencing memory

=== MemoryLayout

a programmatic description of a memory segment's contents

* sequences
* structs
* unions

=== !

[code,java]
----
----

=== hello C

* JNI, old, slow, hard to implement,no major improvements since release,
* and collection of JNI wrappers,
** https://github.com/java-native-access/jna[JNA], open source JNI wrapper,
** https://github.com/jnr/jnr-ffi[jnr-ffi]
** https://github.com/bytedeco/javacpp[JavaCPP]
** https://github.com/jmarranz/jnieasy[JNIEasy]

=== eat your own dog food

JNI is used in many places in JDK (and JVM), +
these things are inherently slow and bloated +
my favorite part java.io and java.net

=== project panama

foreign memory & foreign linker to ease access to native memory and native code

=== goals

Ease of use: Replace JNI with a superior pure-Java development model

=== goals

C support: The initial scope of this effort aims at providing high quality, fully optimized interoperability with C libraries, on x64 and AArch64 platforms.

=== goals

Generality: The Foreign Linker API and implementation should be flexible enough to, over time, accommodate support for other platforms (e.g., 32-bit x86) and foreign functions written in languages other than C (e.g. C++, Fortran).

=== goals

Performance: The Foreign Linker API should provide performance that is comparable to, or better than, JNI.

=== say hi to `CLinker`

* downcalls (e.g. calls from Java to native code), the downcallHandle method can be used to model native functions as plain MethodHandle objects.
* upcalls (e.g. calls from native back to Java code), the upcallStub method can be used to convert an existing MethodHandle (which might point to some Java method) into a MemorySegment, which can then be passed to a native function as a function pointer.

=== core

* CLinker
* LibraryLookup
* FunctionDescriptor

=== too much magic

panama early access builds contain a real gem

=== jextract

it generates Java code from C header files

=== demo


== vectorization

[code,java]
----
x1=y1+z1;
x2=y2+z2;
x3=y3+z3;
x4=y4+z4;
----

=== !

[code,java]
----
[y1,y2,y3,y4]+[z1,z2,z3,z4]
----

=== nothing new

SIMD (Single Instruction Multiple Data)

x86 SSE and AVX extensions +
add new instructions and wide registers

=== !

JVM has support for it for a long time +

but you have almost no control over it

=== intrinsics

`Arrays.fill()` +
`System.arrayCopy()`

these methods have their optimized stubs (not a JNI call)

=== C2 optimizations

JIT tries hard to recognize a patterns in you code and transform it using SIMD

hint: run below code with and without -XX:-UseSuperWord

[code,java]
----
float[] a = ...

for (int i = 0; i < a.length; i++) {
    a[i] = a[i] * a[i];
}
----

=== !

http://groups.csail.mit.edu/commit/papers/00/SLP-PLDI-2000.pdf[ExploitingSuperwordLevelParallelismwithMultimediaInstructionSets]
http://psy-lob-saw.blogspot.com/2015/04/on-arraysfill-intrinsics-superword-and.html[On Arrays.fill, Intrinsics, SuperWord and SIMD instructions]
https://richardstartin.github.io/tags/vector[Richard Startin's Blog, Vectorisation]

=== !

[quote,Richard Starin,Vectorised Algorithms in Java]
Because AVX can reduce the processor frequency, it’s not always profitable to vectorise, so compilers employ cost models to decide when they should do so. Such cost models require platform specific calibration, and sometimes C2 can get it wrong

=== vector api

https://openjdk.java.net/jeps/414[JEP 414: Vector API (Second Incubator)]

=== goals

Clear and concise API — The API should be capable of clearly and concisely expressing a wide range of vector computations consisting of sequences of vector operations composed within loops and possibly with control flow. It should be possible to express a computation that is generic with respect to vector size, or the number of lanes per vector, thus enabling such computations to be portable across hardware supporting different vector sizes

=== goals

Platform agnostic — The API should be CPU architecture agnostic, enabling implementations on multiple architectures supporting vector instructions. As is usual in Java APIs, where platform optimization and portability conflict then the bias will be toward making the API portable, even if that results in some platform-specific idioms not being expressible in portable code.

=== goals

Reliable runtime compilation and performance on x64 and AArch64 architectures — On capable x64 architectures the Java runtime, specifically the HotSpot C2 compiler, should compile vector operations to corresponding efficient and performant vector instructions, such as those supported by Streaming SIMD Extensions (SSE) and Advanced Vector Extensions (AVX). Developers should have confidence that the vector operations they express will reliably map closely to relevant vector instructions. On capable ARM AArch64 architectures C2 will, similarly, compile vector operations to the vector instructions supported by NEON.

=== goals

Graceful degradation — Sometimes a vector computation cannot be fully expressed at runtime as a sequence of vector instructions, perhaps because the architecture does not support some of the required instructions. In such cases the Vector API implementation should degrade gracefully and still function. This may involve issuing warnings if a vector computation cannot be efficiently compiled to vector instructions. On platforms without vectors, graceful degradation will yield code competitive with manually-unrolled loops, where the unroll factor is the number of lanes in the selected vector.

=== core concepts

[ditaa]
....
vector0
+--------+--------+--------+--------+
| lane 0 | lane 1 | lane 2 | lane 3 |
+--------+--------+--------+--------+

vector1
+--------+--------+--------+--------+
| lane 0 | lane 1 | lane 2 | lane 3 |
+--------+--------+--------+--------+
....

=== lane wise operation

[ditaa]
....
+--------+--------+--------+--------+
| lane 0 | lane 1 | lane 2 | lane 3 |
+--------+--------+--------+--------+
    |
    | lane wise operation
    v
+--------+--------+--------+--------+
| lane 0 | lane 1 | lane 2 | lane 3 |
+--------+--------+--------+--------+
....

=== !

[quote,,JEP 414]
A lane-wise operation applies a scalar operator, such as addition, to each lane of one or more vectors in parallel. A lane-wise operation usually, but not always, produces a vector of the same length and shape. Lane-wise operations are further classified as unary, binary, ternary, test, or conversion operations.

=== cross lane operation

[ditaa]
....
+--------+--------+--------+--------+
| lane 0 | lane 1 | lane 2 | lane 3 |
+--------+--------+--------+--------+
    |       ^
    |       | cross lane operation
    +-------+
....

=== !

[quote,,JEP 414]
A cross-lane operation applies an operation across an entire vector. A cross-lane operation produces either a scalar or a vector of possibly a different shape. Cross-lane operations are further classified as permutation or reduction operations.

=== vector shapes

[quote,,JEP 414]
The shape of a vector governs how an instance of Vector<E> is mapped to a hardware vector register when vector computations are compiled by the HotSpot C2 compiler. The length of a vector, i.e., the number of lanes or elements, is the vector size divided by the element size.

=== at runtime

[quote,,JEP 414]
The Vector API has two implementations. The first implements operations in Java, thus it is functional but not optimal. The second defines intrinsic vector operations for the HotSpot C2 run-time compiler so that it can compile vector computations to appropriate hardware registers and vector instructions when available.

=== !

[quote,,JEP 414]
To avoid an explosion of C2 intrinsics we define generalized intrinsics corresponding to the various kinds of operations such as unary, binary, conversion, and so on, which take a parameter describing the specific operation to be performed. Approximately twenty new intrinsics support the intrinsification of the entire API.

=== vector operations

[code,java]
----
static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_PREFERRED;

void vectorComputation(float[] a, float[] b, float[] c) {
    int i = 0;
    int upperBound = SPECIES.loopBound(a.length);
    for (; i < upperBound; i += SPECIES.length()) {
        // FloatVector va, vb, vc;
        var va = FloatVector.fromArray(SPECIES, a, i);
        var vb = FloatVector.fromArray(SPECIES, b, i);
        var vc = va.mul(va)
                   .add(vb.mul(vb))
                   .neg();
        vc.intoArray(c, i);
    }

    // no SIMD
    for (; i < a.length; i++) {
        c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;
    }
}
----

=== WARNING!!!

[quote,,JEP 414]
This implementation achieves optimal performance on large arrays.

=== you may ask yourself how large?

=== demo

=== !

if it doesn't make sens, your not alone

=== !

* no, it is not because there are allocations
* this code is heavily inlined with `@ForceInline`
* looks like generated intrinsics are not optimal (yet)

=== why bother?

C2 will not always recognize your code as _vectorizable_, then
use Vector API (first measure, profile, adapt)

== thank you
